---
kind: xarticle
publish: false
---

____
"Simplicity and elegance are unpopular because they require hard work and discipline to achieve and education to be appreciated". Dijkstra
____

===== link:https://www.youtube.com/watch?v=QM1iUe6IofM[Object-Oriented Programming is Bad]

A very good example of inproperly introduced concept. Strong oppinion and complete ignorance of OO advantages.

And it has some obvious issues:

Around 38:00 he is reasoning that long functions are preferable. 
I think he is missing the point of splitting  a long function into many smaller is also dealing with abstraction level. 

Summary: He has problem with encapsulation. So if you are not afraid of encapsulation you could save 45 minutes . :)﻿

On the other hand I already doing mostly procedural/functional programming even in Java. I have data structures and "action" objects without any significant state. If needed I could compose them togahter into a third object. And it is working quite well.

===== link:http://martinfowler.com/articles/feature-toggles.html[Feature Toggles]

Must have read of feature toggles. It is the new buzzword. Be avare of disadvantages. At the end it is just a few additiona IF in you system!

===== link:http://swreflections.blogspot.lu/2014/08/feature-toggles-are-one-of-worst-kinds.html[Feature Toggles are one of the worst kinds of Technical Debt]

____
build conditional branches into mainline code in order to make logic available only to some users or to skip or hide logic at run-time, including code that isn’t complete (the case for branching by abstraction).

...

And doing this in mainline code to avoid branching is in many ways a step back to the way that people built software 20+ years ago when we didn’t have reliable and easy to use code management systems.

...

Still, there are advantages to developers working this way, making merge problems go away, and eliminating the costs of maintaining and supporting long-lived branches. And carefully using feature flags can help you to reduce deployment risk through canary releases or other incremental release strategies

...

The plumbing and scaffolding logic to support branching in code becomes a nasty form of technical debt, from the moment each feature switch is introduced. Feature flags make the code more fragile and brittle, harder to test, harder to understand and maintain, harder to support, and less secure.

...

Feature Flags need to be Short Lived

...

it can get harder to support and debug the system, keeping track of which flags are in which state in production and test can make it harder to understand and duplicate problems.

...

And there are dangers in releasing code that is not completely implemented, especially if you are following branching by abstraction and checking in work-in-progress code protected by a feature flag. If the scaffolding code isn't implemented correctly you could accidentally expose some of this code at run-time with unpredictable results.

...

As more flags get added, testing of the application becomes harder and more expensive, and can lead to an explosion of combinations

...

And other testing needs to be done to make sure that switches can be turned on and off safely at run-time, and that features are completely and safely encapsulated by the flag settings and that behaviour doesn’t leak out by accident (especially if you are branching in code and releasing work-in-progress code). You also need to test to make sure that the structural changes to introduce the feature toggle do not introduce any regressions, all adding to testing costs and risks.

...

More feature flags also make it harder to understand how and where to make fixes or changes, especially when you are dealing with long-lived flags and nested options.
____


===== link:https://lostechies.com/jimmybogard/2012/10/23/feature-branches-and-toggles/[]

Not everying is so wrong. Instead of feature toggles you could use proper branching strategies to eliminate feature branch weakness as much as possible.

____
he argument against feature branches are not just merge problems, but semantic merge problems, such as a method rename. This leads to a fear of refactoring, and

Indeed I see this as the decisive reason why Feature Branching is a bad idea. Once a team is afraid to refactor to keep their code healthy they are on downward spiral with no pretty end.

...

If I’m surprised about refactoring based on a merge, this is a failure in communication from the team.

...

But this assumes a faulty strategy – that large refactorings happen solely in feature branches. But for larger refactorings, these can be thought of features themselves

...

The alternative is a Continuous Integration (across branches)

image::http://martinfowler.com/bliki/images/featureBranch/continuous.png[]

...

In order to mitigate merge risks, I simply make sure I don’t have long-running branches. 

____

Other readings

- link:http://fernandorubbo.blogspot.lu/2013/03/feature-toggles-good-or-bad.html[]
- link:http://abhishek-tiwari.com/post/decoupling-deployment-and-release-feature-toggles[]

===== link:https://www.youtube.com/watch?v=pU1gXA0rfwc[Wait, what!? Our microservices have actual human users?]

Pragmatic approach of micrservices. Build multiple websites which looks like being the same. Even multiple Single page application.

- An article: link:http://www.infoq.com/news/2016/02/tilkov-microxchg-human-users[]
- slides: link:https://speakerdeck.com/stilkov/wait-what-our-microservices-have-actual-human-users[]

===== link:https://www.youtube.com/watch?index=4&v=KSEyIXnknoY&list=PL8B19C3040F6381A2[PatternCraft - Visitor Pattern]

Design Patterns explained with StarCraft. Very cool!

===== link:http://engineering.skybettingandgaming.com/2016/02/02/how-we-release-so-frequently/[How We Release So Frequently]

____
We have a lot of tests


Forward-only Migrations

We don’t roll back database migrations. 
every database migration we do results in a schema that’s compatible with the new version of our code and the previous one. If we have to roll back a code release (that does happen sometimes) then the previous version is perfectly happy using the new version of the schema.

How we acheive this isn’t with some magical technical solution, but purely by convention. Take dropping a column as an example; how do you release that change? Easy:

- Release a version of the code that doesn’t use that column; ensure it is stable / won’t be rolled back.
- Do a second release that has a migration to remove the column.

New Code != New Features
Customers should never notice a code release, unless perhaps there’s a dramatic improvement in performance.
Every new feature is first released in a hidden state, ready to be turned on with a ‘feature toggle’.

Small Releases
With fast builds, lots of tests, less risky database migrations, and feature changes decoupled from code releases: there’s not much standing in the way of us releasing our code often, but there is a feeback loop here that helps us even further: the more often we release, the smaller the releases can be. Smaller releases carry less risk, letting us release even more often. Frequent releases don’t necessarily imply small releases though - it still requires a bit of convention.
____



===== Twitter

"IT is a cost center you say? Ok, let's shut all the servers down until you figure out what part of revenue we contribute to." - @drunkcod

Your mgrs want data about agile. You try to find some data. But data reinforces your own confirmation bias. @RisingLinda


